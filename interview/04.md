---
title: encrypt
categories:
 - interview
---

### 加密

对称加密：解密和加密都使用一个密钥。这样如果在传输过程中，或者在客户端的密钥被泄露，就会存在整个传输内容泄密的情况发生，显然这种加密方式是存在问题的。
> 常见的对称加密算法：DES，AES等

非对称加密：公钥加密的数据，只有对应的私钥才能解密。私钥加密的数据只有对应的公钥才能解密。一般讲私钥存在服务器，公钥可以存在每个客户端。服务器向客户端发数据，由私钥加密数据，然后由客户端公钥解密。客户端向服务器发数据，由公钥加密，服务器私钥解密。整个过程中不存在传输密钥的情况，也就不会造成密钥的丢失。(注意客户端要确保拿到的公钥是服务器的，一般用CA来实现，但是如果私底下配置好了就不用CA了)
> 最常用的非对称加密算法：RSA

采用非对称加密技术来交换 **对称加密密钥** ，之后的通信都采用对称加密技术加密(先非对称后对称)

### SSH(Secure Shell)

> SSH为 创建在应用层和传输层基础上的安全协议，为计算机上的Shell(壳层)提供安全的传输和使用环境

- SSH采用先 非对称后对称 进行数据加密 但是有中间人攻击问题
- 黑客H埋伏在了A和B之间的某一个路由器上，他假冒B生成一对公私密钥，然后把公钥发送给A，这样A与H之间就建成了一个加密通道，A把所有信息发送给H，H截获A的信息，在假冒A与B通信。
- 如此一来，A、B之间的通信就完全暴漏给了H，而A、B却完全不知道，这就是的中间人攻击。
- SSH协议采用由人工判断公钥的fingerprint是否可信的方式。当使用ssh命令连接服务器时，命令行会提示如下信息:

```shell
RSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53.
Are you sure you want to continue connecting (yes/no)? 
```

fingerprint其实就代表公钥,这种认证方式是指用户已经知道服务器公钥(黑客不可能发一个与服务器一模一样的公钥)，这样就解决了问题

### 为更广大群众设计的SSL与TLS

- SSH弊端：SSH其实是专门为shell设计的一种通信协议，只有SSH客户端，和SSH服务器端之间的通信才能使用这个协议

- SSL与TLS(SSL协议的一个后续版本)是一个通用的，建立在应用层之下的一个传输层安全协议，不管是HTTP、FTP等应用层协议都可以依赖的安全通信的传输层协议(应用层和传输层之间的一个安全通道)

- SSH通过fingerprint来解决中间人问题，那么SSL是通过数字证书(CA数字证书认证机构颁发的)来解决的

  - 浏览器在与服务器建立SSL连接时，获取服务器的数字证书

  - 证书里面有签名(服务器公钥经过CA私钥加密生成的)

  -  这样浏览器得到证书，用CA的公钥（每个浏览器都存储着一些权威CA的公钥）对数字签名解密，得到了服务器公钥

  -  解密成功说明证书是真的(不是中间人发的)，信任问题就这么解决了，就可以用公钥了

### HTTPS(Hypertext Transfer Protocol Secure)

> HTTP over TLS 或者 HTTP over SSL,其实就客户端与服务器之间的HTTP通信基于TLS或SSL协议。

作为网站管理员申请数字证书：首先要为服务器生成一对公私钥，然后将公钥一起发送给某个权威的CA，CA会通过某种方式认证申请人是否真的是网站的所有人，验证通过就会得到证书了。

### 使用加密算法能保证密码安全吗

- 对称加密

前端加密无非是写在JS里，但是JS有风险被直接破解从而识别加密方法

- HTTPS就一定安全吗

    - HTTPS可以保证传输过程中的信息不被别人截获，但是细细思考下，HTTPS是应用层协议，下层采用SSL保证信息安全，但是在客户端和服务端，密文同样是可以被截获的

    - HTTPS报文在传输过程中，如果客户端被恶意引导安装“中间人”的WEB信任证书，那么HTTPS中的“中间人攻击”一样会将明文密码泄露给别人

- 无论HTTP还是HTTPS，密码必须密文传输

- 黑客拿到密码密文，然后发送给服务器不是一样可以登录，解决方式：token令牌，每次从服务器中获取认证的token，确实能保证HTTP请求是由前端传回来的，因为token在每次接口访问后都会删除并被重置，黑客尝试**重放**账号密码数据信息来登陆的时候导致无法成功登陆

### 数据篡改

- 密码加密了，黑客看不到明文了；加上token，登陆过程也没法再被截获重放了

- 当请求路由到黑客这边的时候，截获数据包，然后也不需要登录，反正账号密码都是对的，token也是对的，那么把数据包的字段改改，搞破坏就可以了

- 解决：数字签名

### 签名vs加密

> 数据签名和数据加密的过程都是使用公开的密钥系统，但实现的过程正好相反

- 公钥和私钥唯一对应，用某个公钥签名过得内容只能用对应的私钥才能解签验证；同样用某个私钥加密的内容只能用对应的公钥才能解密

- 公钥一般用来加密，私钥用来签名

- A向B发送信息的整个签名和加密的过程如下：

  - A用自己的私钥对data进行签名
  
  - A使用B的公钥对全部报文进行加密

- B接收到A的信息后，获取信息内容的步骤如下：

  - B用自己的私钥加密的内容
  
  - 得到解密后的明文后用A的公钥解签A的签名获取data

总结：A的签名只有A的公钥才能解签，这样B就能确认这个信息是A发来的；A的加密只有B的私钥才能解密，这样A就能确认这份信息只能被B读取

### JS加密函数存在被破解

摘要或加密JS算法不直接以静态文件的形式存在浏览器中，而是让WEB端去请求Server，服务器可以根据随机令牌token值决定返回一个相应随机的加密策略，以JS代码响应的方式返回，在异步请求响应中，加载JS摘要算法，这样客户端就可以动态加载数字摘要策略，保证无法仿造


### 加解密流程
1、首先由客户端去请求服务器的公钥(rsaPublicKey)，由服务器生成密钥对，服务器存公钥(rsaPublicKey)和私钥(rsaPrivateKey)，将公钥发送给客户端；

2、客户端拿到公钥，保存公钥，为下一步发起请求做准备；

3、客户端准备发起请求，首先生成随机aes密钥(aesKey)；

4、客户端使用aesKey对要加密的数据进行对称加密，生成加密数据encryptData；

5、客户端使用ras公钥(rasPublicKey)对aeskey进行加密，得到得到encryptAesKey；

6、客户端正式发起请求，将encryptAesKey放在请求头，将encryptData放在请求体；

7、服务器收到请求，首先拿到请求头的encryptAesKey，使用对应rsaPriavteKey对encryptAesKey解密拿到aesKey；

8、服务器使用aesKey对请求体中的encryptData进行解密，得到明文请求内容；

9、服务器做出响应，将返回数据由aesKey加密，返回给客户端；

10、客户端收到服务器响应，由发起请求的aesKey解密返回数据，拿到明文数据。结束一次请求。下次请求从**步骤4**开始。

> 步骤1中，这里公钥通过网络发送到了客户端，也可以直接存在客户端。


除了提高数据的安全性之外，还有一个问题值得关注，那就是对用户身份的验证。也就是由客户端对数据签名和服务端对数据验签的过程。具体的步骤如下：

1、由客户端生成密钥对，并在通讯正式开始前，把公钥交到服务端手里

2、每次发出消息，都有客户端的私钥对数据进行加密(这里看需要了，可以是对消息的摘要进行加密，也可以对固定的字符串，但是记住消息加密内容不能过长的原则)得到签名信息(加签)和未加密的数据发送给服务端

3、服务端在收到消息后首先用客户端之前的公钥对数据进行解密(验签)，如果失败了，那身份验证就失败了；如果成功了，再与明文数据对比是否一致，如果一致，就认为身份验证通过了。

> 可以把加密解密，签名验签结合使用。
