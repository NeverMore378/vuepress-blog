---
title: communication
categories:
 - interview
---

### 幂等

> 不论你请求多少次，资源的状态是一样的。

|类别|幂等|适合|
|---|---|---|
|GET|yes|查询
|POST|no|新增
|PUT|yes|修改
|DELETE|yes|删除

### 跨域

- 浏览器从一个域名的网页去请求另一个域名的资源时，域名(ip)、端口、协议任一不同，都是跨域

- 短连接

> 客户端和服务器每进行一次通讯,就建立一次连接,通讯结束就中断连接
>
> HTTP是请求-响应协议,它运行在TCP之上,HTTP/1.0默认是短连接

- 长连接

> 是指在建立连接后可以连续多次发送数据,直到双方断开连接
>
> HTTP从1.1版本起,默认是长连接,响应头:Connection:keep-alive

### WebSocket

> WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议
>
> 在WebSocket中浏览器和服务器只需要完成一次握手，就可以创建持久性的连接，并进行双向数据传输
>
> 在推送功能的实现技术上，相比使用Ajax定时轮询的方式，WebSocket更节省服务器资源和带宽
>
> HTTP协议有一个缺陷:通信只能由客户端发起,做不到服务器主动向客户端推送信息,服务器主动向客户端发送数据是WebSocket协议的典型使用场景

```javascript
var ws = new WebSocket("wss://echo.websocket.org");

ws.onopen = function(evt) { 
  console.log("Connection open ..."); 
  ws.send("Hello WebSockets!");
};

ws.onmessage = function(evt) {
  console.log( "Received Message: " + evt.data);
  ws.close();
};

ws.onclose = function(evt) {
  console.log("Connection closed.");
};
```


在建立好http连接之后发送请求头升级为ws连接

- 客户端

```html
<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <title>websocket 客户端</title>
    <script type="text/javascript">
        function WebSocketTest() {
            if (window.WebSocket) {
                let ws = new WebSocket("ws://localhost:8887");
                ws.onopen = function () {
                    alert("已连接");
                    ws.send("xzj");
                };
                ws.onmessage = function (evt) {
                    let msg = evt.data;
                    alert("数据接收:" + msg);
                };
                ws.onclose = function () {
                    alert("连接已关闭...");
                };
            } else {
                alert("您的浏览器不支持 WebSocket!");
            }
        }
    </script>
</head>
<body>
<div>
    <a href="javascript:WebSocketTest()">运行 WebSocket</a>
</div>
</body>
</html>

```
- 服务端
```xml
<dependency>
    <groupId>org.java-websocket</groupId>
    <artifactId>Java-WebSocket</artifactId>
    <version>1.4.0</version>
</dependency>
```

```java
public class ServerDemo extends WebSocketServer {

    public ServerDemo(int port) {
        super(new InetSocketAddress(port));
        System.out.println("websocket Server start at port:" + port);
    }

    @Override
    public void onOpen(WebSocket conn, ClientHandshake clientHandshake) {
        System.out.println("new connection ===" + conn.getRemoteSocketAddress().getAddress().getHostAddress());
    }

    @Override
    public void onClose(WebSocket conn, int code, String reason, boolean remote) {

    }

    @Override
    public void onMessage(WebSocket conn, String message) {
        System.out.println("you have a new message: " + message);
        conn.send(message);
    }

    @Override
    public void onError(WebSocket conn, Exception e) {
    }

    @Override
    public void onStart() {
    }

    public static void main(String[] args) {
        new ServerDemo(8887).start();
    }
}
```

会发送ws://localhost:8887请求

### Netty

- NIO编程

新来一个连接不再创建一个新的线程，而是可以把连接直接绑定到某个固定的线程，然后这条连接所有的读写都由这个线程来负责

连接来了之后，注册到选择器(Selector)，Thread检查这个选择器，就可以批量操作

- NIO三大核心组件

通道(Channel)、缓冲(Buffer)、选择器(Selector)

Channel是BIO中的Stream(流)的升级，Stream是单向的，Channel是双向的，进行读操作同时，又可以进行写操作

Buffer可以理解为一块内存区域，可以写入数据，并且在之后读取它

Selector可以实现一个单独的线程来监控多个注册在上面的Channel，通过一定的选择机制，实现多路复用的效果

- NIO与IO

IO是阻塞的，当一个线程读或写时，该线程被阻塞，直到有一些数据被完全读取，或数据完全写入，在此期间该线程不能干其他任何事情，而NIO是非阻塞的

NIO引入了IO多路复用器selector

### 接口加密

> 明文传输的数据会被人用抓包工具抓取(wireshark)，从而威胁系统和数据的安全性

- 摘要算法(MD5)

> 把任意长度的输入产生长度固定的信息,不需要密钥,并且经过加密的数据无法被解密,只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文

- 对称加密(DES、AES)

> 加密和解密使用相同密钥的加密算法

- 非对称加密(RSA)

> 公钥与私钥是一对,用公钥对数据进行加密，只有用对应的私钥才能解密

- 数字签名

> 作用:确定消息确实是由发送方签名并发出来的、确定消息的完整性
