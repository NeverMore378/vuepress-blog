---
title: senior
categories:
 - interview
---

### ArrayList和LinkedList区别

---

- 首先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的
  
- 由于底层数据结构不同，他们所适⽤的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同
  
- 另外ArrayList和LinkedList都实现了List接⼝，但是LinkedList还额外实现了Deque接⼝，所以LinkedList还可以当做队列来使⽤

### HashMap的Put⽅法

---

- 根据Key通过Hash与运算得出数组下标
  
- 如果数组下标位置元素为空，则将key和value封装为Entry对象（JDK1.7中是Entry对象，JDK1.8中是Node对象）并放⼊该位置

- 如果数组下标位置元素不为空，则要分情况讨论
  
   - 如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进⾏扩容，如果不⽤扩容就⽣成Entry对象，并使⽤头插法添加到当前位置的链表中
     
   - 如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红⿊树Node，还是链表Node
     
     - 如果是红⿊树Node，则将key和value封装为⼀个红⿊树节点并添加到红⿊树中去，在这个过程中会判断红⿊树中是否存在当前key，如果存在则更新value
       
     - 如果此位置上的Node对象是链表节点，则将key和value封装为⼀个链表Node并通过尾插法插⼊到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前key，如果存在则更新value，当遍历完链表后，将新链表Node插⼊到链表中，插入到链表后，会看当前链表的节点个数，如果⼤于等于8，那么则会将该链表转成红⿊树
       
     - 将key和value封装为Node插⼊到链表或红⿊树中后，再判断是否需要进⾏扩容，如果需要就扩容，如果不需要就结束PUT⽅法

### ThreadLocal

---

- ThreadLocal是Java中提供的线程本地存储机制，可以利⽤该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意⽅法中获取缓存的数据
  
- ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在⼀个ThreadLocalMap，ThreadLocalMap的key为ThreadLocal对象本身，ThreadLocalMap的value为需要缓存的值

- 如果在线程池中使⽤ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使⽤完之后，应该要把设置的key和value，也就是Entry对象进⾏回收，但线程池中的线程不会回收，⽽线程对象是通过强引⽤指向ThreadLocalMap，ThreadLocalMap也是通过强引⽤指向Entry对象，线程不被回收，Entry对象也就不会被回收，从⽽出现内存泄漏，解决办法是，在使⽤了ThreadLocal对象之后，⼿动调⽤ThreadLocal的remove⽅法，⼿动清除Entry对象
  
- ThreadLocal经典的应⽤场景就是连接管理（⼀个线程持有⼀个连接，该连接对象可以在不同的⽅法之间进⾏传递，线程之间不共享同⼀个连接）

```java
public class ThreadLocalExample {

   public static class MyRunnable implements Runnable {

      private ThreadLocal threadLocal = new ThreadLocal();

      @Override
      public void run() {
         threadLocal.set((int) (Math.random() * 100D));
         try {
            Thread.sleep(2000);
         } catch (InterruptedException e) {

         }
         System.out.println(threadLocal.get());
      }
   }

   public static void main(String[] args) {
      MyRunnable sharedRunnableInstance = new MyRunnable();
      Thread thread1 = new Thread(sharedRunnableInstance);
      Thread thread2 = new Thread(sharedRunnableInstance);
      thread1.start();
      thread2.start();
   }

}
```

- 创建了一个MyRunnable实例，并将该实例作为参数传递给两个线程。两个线程分别执行run()方法，并且都在ThreadLocal实例上保存了不同的值。如果它们访问的不是ThreadLocal对象并且调用的set()方法被同步了，则第二个线程会覆盖掉第一个线程设置的值。但是，由于它们访问的是一个ThreadLocal对象，因此这两个线程都无法看到对方保存的值。也就是说，它们存取的是两个不同的值。

```java
    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
        }
```

### JVM中，哪些是共享区，哪些可以作为 gc root

---

- 堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的

- JVM在进⾏垃圾回收时，需要找到“垃圾”对象，也就是没有被引⽤的对象，但是直接找“垃圾”对象是⽐较耗时的，所以反过来，先找“⾮垃圾”对象，也就是正常对象，那么就需要从某些“根”开始去找，根据这些“根”的引⽤路径找到正常对象，⽽这些“根”有⼀个特征，就是它只会引⽤其他对象，⽽不会被其他对象引⽤，例如：栈中的本地变量、⽅法区中的静态变量、本地⽅法栈中的变量、正在运⾏的线程等可以作为gc root。

### 排查JVM问题

---

- 可以使⽤jmap来查看JVM中各个区域的使⽤情况
  
- 可以通过jstack来查看线程的运⾏情况，⽐如哪些线程阻塞、是否出现了死锁

### 线程之间如何通讯

---

- 线程之间可以通过共享内存或基于网络来进行通信

- 通过共享内存来进⾏通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒，像Java中的wait()、notify()就是阻塞和唤醒

- 通过网络就比较简单了，通过网络连接将通信数据发送给对⽅，当然也要考虑到并发问题，处理方式就是加锁等⽅式

### Spring流程

---
  
- 启动Spring时：

    - 首先会进行扫描，扫描得到所有的BeanDefinition对象，并存在⼀个Map中 
      
    - 然后筛选出非懒加载的单例BeanDefinition进⾏创建Bean，对于多例Bean不需要在启动过程中去进⾏创建，对于多例Bean会在每次获取Bean时利⽤BeanDefinition去创建
      
    - 利⽤BeanDefinition创建Bean就是Bean的创建⽣命周期，这期间包括了合并BeanDefinition、推断构造⽅法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发⽣在初始化后这⼀步骤中
  
- Spring的扫描就是通过BeanFactoryPostProcessor来实现的，依赖注⼊就是通过BeanPostProcessor来实现的

### Spring的事务机制

---

- Spring事务底层是基于数据库事务和AOP机制的
  
- ⾸先对于使⽤了@Transactional注解的Bean，Spring会创建⼀个代理对象作为Bean

- 当调⽤代理对象的⽅法时，会先判断该⽅法上是否加了@Transactional注解
  
- 如果加了，那么则利⽤事务管理器创建⼀个数据库连接
  
- 并且修改数据库连接的autocommit属性为false，禁⽌此连接的⾃动提交，这是实现Spring事务⾮常重要的⼀步
  
- 然后执⾏当前⽅法，⽅法中会执⾏sql
  
- 执⾏完当前⽅法后，如果没有出现异常就直接提交事务
  
- 如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务
  
- Spring事务的隔离级别对应的就是数据库的隔离级别
  
- Spring事务的传播机制是Spring事务⾃⼰实现的，也是Spring事务中最复杂的
  
- Spring事务的传播机制是基于数据库连接来做的，⼀个数据库连接⼀个事务，如果传播机制配置为需要新开⼀个事务，那么实际上就是先建⽴⼀个数据库连接，在此新数据库连接上执⾏sql

### @Transactional失效

---

- 因为Spring事务是基于代理来实现的，所以某个加了@Transactional的⽅法只有是被代理对象调⽤时，那么这个注解才会生效；如果是被代理对象来调⽤这个⽅法，那么@Transactional是不会⽣效的。
  
```java
    public Boolean insertDept() {
        // 会失效
        // 默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰
        this.addDept();
        return true;
    }
    
    @Transactional
    public void addDept() {
        int i = 1/0;
    }
```

- @Transactional注解只能应用到public可见度的方法上，因为底层cglib是基于父子类来实现的，⼦类是不能重载⽗类的private⽅法的，所以⽆法利⽤代理，也会导致@Transactianal失效

### Dubbo是如何做系统交互的

---

- Dubbo底层是通过RPC来完成服务和服务之间的调⽤的，Dubbo⽀持很多协议，比如默认的dubbo协议、http协议、rest等都是⽀持的，他们的底层所使⽤的技术是不太⼀样的，⽐如dubbo协议底层使⽤的是netty，也可以使⽤mina，http协议底层使⽤的tomcat或jetty。
  
- 服务消费者在调用某个服务时，会将当前所调⽤的服务接⼝信息、当前方法信息、执行方法所传入的入参信息等组装为⼀个Invocation对象，然后不同的协议通过不同的数据组织方式和传输方式将这个对象传送给服务提供者，提供者接收到这个对象后，找到对应的服务实现，利用反射执⾏对应的⽅法，得到方法结果后再通过网络响应给服务消费者。
  
- 当然，Dubbo在这个调用过程中还做很多其他的设计，比如服务容错、负载均衡、Filter机制、动态路由机制等等，让Dubbo能处理更多企业中的需求。

### Netty

- NIO编程

新来一个连接不再创建一个新的线程，而是可以把连接直接绑定到某个固定的线程，然后这条连接所有的读写都由这个线程来负责

连接来了之后，注册到选择器(Selector)，Thread检查这个选择器，就可以批量操作

- NIO三大核心组件

通道(Channel)、缓冲(Buffer)、选择器(Selector)

Channel是BIO中的Stream(流)的升级，Stream是单向的，Channel是双向的，进行读操作同时，又可以进行写操作

Buffer可以理解为一块内存区域，可以写入数据，并且在之后读取它

Selector可以实现一个单独的线程来监控多个注册在上面的Channel，通过一定的选择机制，实现多路复用的效果

- NIO与IO

IO是阻塞的，当一个线程读或写时，该线程被阻塞，直到有一些数据被完全读取，或数据完全写入，在此期间该线程不能干其他任何事情，而NIO是非阻塞的

NIO引入了IO多路复用器selector
