---
title: 并发
categories:
 - interview
---

### 线程的生命周期

---

- 线程通常有五种状态:创建，就绪，运行、阻塞和死亡

- 阻塞的情况又分为三种
  
    - 等待阻塞：运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或notifyAll方法才能被唤醒，wait是Object类的方法

    - 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中

    - 其他阻塞：运行的线程执行sleep或join方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep状态超时、join等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。sleep是Thread类的方法

### sleep()、wait()、join()、yield()的区别

---

- 锁池

所有需要竞争同步锁的线程都会放在锁池当中，当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu资源分配

- 等待池

当调用wait()方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了notify()或notifyAll()后等待池的线程才会开始去竞争锁，notify()是随机从等待池选出一个线程放到锁池，而notifyAll()是将等待池的所有线程放到锁池当中

- sleep vs wait
  
  - sleep是Thread方法，wait则是Object方法
  
  - sleep方法不会释放lock，但是wait会释放
  
  - sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized

  - sleep不需要被唤醒，但是wait需要
  
  - sleep一般用于当前线程休眠，或者轮循暂停操作，wait则多用于多线程之间的通信
  
- yield

yield()执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行

- join

join()执行后线程进入阻塞状态，例如在线程B中调用线程A的join()，那线程B会进入到阻塞队列，直到线程A结束或中断线程

```java
    // 111
    // 222
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            try {
                Thread.sleep(3000);
                System.out.println(111);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread.start();
        try {
            // 在主线程中执行thread的join()方法，必须要等到thread结束后，才会执行主线程的方法
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(222);
    }

```

### Thread、Runable的区别

---

Thread和Runnable的实质是继承关系，没有可比性。无论使用Runnable还是Thread，都会new Thread，然后执行start()

### 守护线程

---

当 JVM 中不存在任何一个正在运行的非守护线程时，则 JVM 进程即会退出

![1](./1.png)

![2](./2.png)

可以看到因为有一个非守护线程一直在后台运行着，JVM 无法正常退出。那么，如果说正在运行的是个守护线程，结果又会怎么样呢

![3](./3.png)

![4](./4.png)

可以看到，当主线程退出时，JVM 会随之退出运行，守护线程同时也会被回收，即使你里面是个死循环也不碍事

JVM 中的垃圾回收线程就是典型的守护线程，如果说不具备该特性，会发生什么呢

当 JVM 要退出时，由于垃圾回收线程还在运行着，导致程序无法退出

通常来说，守护线程经常被用来执行一些后台任务，但是呢，你又希望在程序退出时，或者说 JVM 退出时，线程能够自动关闭，此时，守护线程是你的首选

### ThreadLocal

---

- 每一个Thread对象均含有一个ThreadLocalMap类型的成员变量threadLocals，threadLocals存储本线程中**所有**ThreadLocal对象及其对应的值

- ThreadLocalMap由一个个Entry对象构成(Entry数组)

- Entry继承自WeakReference<ThreadLocal<?>>，一个Entry由ThreadLocal对象和Object构成。Entry的key是ThreadLocal对象，并且是一个弱引用。当没指向key的强引用后，该key就会被垃圾收集器回收

- 当执行set方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，将值存储进ThreadLocalMap对象中。
  
- 当执行get方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，获取对应的value。

- 由于每一条线程均含有各自私有的ThreadLocalMap容器，这些容器相互独立互不影响，因此不会存在线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。

- 使用场景

  - Java的Web项目大部分都是基于Tomcat，每次访问都是一个新的线程，每一个线程都独享一个ThreadLocal，在接收请求的时候set特定内容，在需要的时候get这个值
  
  - 进行事务操作，用于存储线程事务信息
  
  - 数据库连接，Session会话管理
  
    - Spring在事务开始时会给当前线程绑定一个Jdbc Connection,整个事务过程都是使用该线程绑定的connection来执行数据库操作，实现了事务的隔离性,用的ThreadLocal来实现这种隔离

![5](./5.png)

### ThreadLocal内存泄露

--- 

- 强引用：使用最普遍的引用(new)或者反射创建对象，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，JVM宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。

  - 如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象

- 弱引用：JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示

- ThreadLocal的实现原理：每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal实例，value为线程变量的副本

- ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部强引用时(ThreadLocalRef与ThreadLocal断开)，Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强引用，只有thead线程结束(或者调用ThreadLocal的get()、set()、remove()),value的强引用链条才会断掉，但如果当前线程不结束或者不调用那些方法的话，这些key为null的Entry的value就会一直存在一条强引用链（红色链条）

  - 假如key是强引用：当ThreadLocalMap的key为强引用，并且ThreadLocalRef与ThreadLocal断开，回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收（那么就存在红色链条），导致Entry内存泄漏

  - 所以key是弱引用：当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收，此时key为null，在下一次ThreadLocalMap调用set(),get()，remove()方法的时候会被清除value值

- ThreadLocal内存泄漏的根源：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用

- 每次使用完ThreadLocal都调用它的remove()方法清除数据


