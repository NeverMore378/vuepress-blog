---
title: 基础
categories:
 - interview
---

#### 面向对象

---

- 封装
  
    - javabean的属性私有，提供getset对外访问

    - 操作数据库，我们不需要关心链接是如何建立的、sql是如何执行的，只需要引入mybatis，调方法即可

- 继承

    - 继承基类的方法，并做出自己的改变和/或扩展

    - 子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的

- 多态

    - 子类不同但是同一个父类，外部对同一个方法的调用，实际执行的是各自的子类的方法

> 父类 变量名 = new 子类

无法调用子类特有的变量和方法

#### JDK JRE JVM

---

> JDK包含JRE(bin和lib(类库))和Java工具(javac、java、jconsole)

java文件 -> class文件 -> jvm运行 （jvm调用lib(类库)解释然后映射到操作系统（即系统调用））

#### ==和equals比较

---
- ==：基本数据类型是变量值，引用类型是堆中内存对象的地址

- equals:Object中默认也是采用==比较，通常会重写(比如String)

#### hashCode与equals

---
- 散列码:它实际上是返回一个int整数。作用是确定该对象在哈希表中的索引位置。

- HashSet如何检查重复:先计算对象的hashcode值来判断对象加入的位置，但是如果发现有值，这时会调用equals方法来检查两个对象是否真的相同

- equals方法被覆盖过，则hashCode方法也必须被覆盖

#### final

---

- 修饰类：表示类不可被继承

- 修饰方法：表示方法不可被子类覆盖

- 修饰变量：表示变量一旦被赋值就不可以更改它的值

```java
    final int[] iArr={1,2,3,4};
    //合法
    iArr[2]=-3;
    //非法，对iArr不能重新赋值
    iArr=null;
```

#### String、StringBuffer、StringBuilder

---

- String是final修饰的，不可变，每次操作都会产生新的String对象，StringBuffer和StringBuilder都是在原对象上操作

- StringBuffer是线程安全的，StringBuilder线程不安全的

- 性能：StringBuilder > StringBuffer > String

#### 重载和重写的区别

---
- 重载： 发生在同一个类中

- 重写： 发生在父子类中，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类

#### 接口和抽象类的区别

---

- 抽象类可以存在任何方法，而接口中只能存在public abstract 方法
  
- 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的

- 抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。

- 接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。

#### List和Set的区别

---

- List：有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出所有元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素

- Set：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用Iterator接口取得所有元素，在逐一遍历各个元素

#### ArrayList和LinkedList区

---

- ArrayList：基于动态数组，连续内存存储，适合下标访问（随机访问）
  
    - 扩容机制：因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组

- LinkedList：基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询：需要逐一遍历

#### HashMap和HashTable有什么区别

---

- HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；
  
- HashMap允许key和value为null，而HashTable不允许

- HashMap底层实现：数组+链表+红黑树实现

    - jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树

    - 元素以内部类Node节点存在

    - 计算key的hash值，二次hash然后对数组长度取模，对应到数组下标，如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组

    - 如果产生hash冲突，先对key进行equal比较，相同则取代该Node

    - 不同，则判断链表高度插入链表，链表高度达到8，并且数组长度到64则转变为红黑树

    - 长度低于6则将红黑树转回链表

#### ConcurrentHashMap

---

- jdk7

  - 数据结构：ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个HashEntry又是一个链表结构

  - 元素查询：二次hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部

  - 锁：Segment分段锁 Segment继承了ReentrantLock，锁定操作的Segment，其他的Segment不受影响，并发度为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment
  
  - get方法无需加锁，volatile保证
  
- jdk8

  - 数据结构：synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性
  
  - 查找，替换，赋值操作都使用CAS
  
  - 锁：锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作、并发扩容
  
  - 读操作无锁：Node的val和next使用volatile修饰，读写线程对该变量互相可见，数组用volatile修饰，保证扩容时被读线程感知

#### 集合取值问题

---

```java
    public static void main(String[] args) {
        List<List<Integer>> list = new ArrayList<>();
        List<Integer> list1 = new ArrayList<>();
        list1.add(1);
        list1.add(2);
        List<Integer> list2 = new ArrayList<>();
        list2.add(3);
        list2.add(4);
        list.add(list1);
        list.add(list2);
        System.out.println(list);
        List<Integer> integers = list.get(0);
        integers.add(3);
        System.out.println(list);
    }
```

> [[1, 2], [3, 4]]
> 
> [[1, 2, 3], [3, 4]]

```java
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        System.out.println(list);
        String integers = list.get(0);
        integers = null;
        System.out.println(list);
    }
```

> [a, b]
> 
> [a, b]

#### Java中的异常体系

---

- Java中的所有异常都来自顶级父类Throwable

- Throwable下有两个子类Exception和Error
  
- Error是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行

- Exception不会导致程序停止，又分为两个部分RunTimeException运行时异常和CheckedException检查异常

- RunTimeException常常发生在程序运行过程中，会导致程序当前线程执行失败;CheckedException常常发生在程序编译过程中，会导致程序编译不通过

#### Java类加载器

---

- JDK自带有三个类加载器：Bootstrap ClassLoader、ExtClassLoader、AppClassLoader
  - BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%lib下文件。

  - ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext下的文件。

  - AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件。系统类加载器，线程上下文加载器

- 继承ClassLoader实现自定义类加载器

#### 双亲委派

---

- 主要是为了安全性，避免用户自己编写的类动态替换 Java的一些核心类，比如 String

- 同时也避免了类的重复加载，因为JVM中区分不同类，不仅仅是根据类名，相同的 class文件被不同的 ClassLoader加载就是不同的两个类

### GC如何判断对象可以被回收

---

- 引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收

- 可达性分析法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象

> 引用计数法，可能会出现A 引用了 B，B 又引用了 A，这时候就算他们都不再使用了，但因为相互引用 计数器=1 永远无法被回收


GC Roots的对象有:

- 虚拟机栈(栈帧中的本地变量表）中引用的对象

- 方法区中类静态属性引用的对象

- 方法区中常量引用的对象

- 本地方法栈中JNI(即一般说的Native方法)引用的对象

可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至少要经历两次标记过程：第一次是经过可达性分析发现没有与GC Roots相连接的引用链。第二次是在由虚拟机自动建立的Finalizer队列中判断是否需要执行finalize()方法。

当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”

每个对象只能触发一次finalize()方法

由于finalize()方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，不推荐使用
