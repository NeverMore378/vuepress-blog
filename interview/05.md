---
title: SSH&SSL
categories:
 - interview
---

### 对称加密

- 在1976年以前，所有的加密都采用对称加密，既A使用某种加密规则对信息加密，B收到信息后逆向加密规则解密数据

  - 缺点：A如何安全的把加密规则通知B

  - 优点：效率高、速度快

  - 常见的对称加密算法：DES，AES等

### 非对称加密


- B(服务器)生成一对两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。
- A(客户端)获取B生成的公钥，然后用它对信息加密。
- B得到加密后的信息，用私钥解密。

> 最常用的非对称加密算法：RSA


### 对称加密+非对称加密

> 采用非对称加密技术来交换 **对称加密密钥** ，之后的通信都采用对称加密技术加密(先非对称后对称)

### SSH(Secure Shell)

> SSH为 创建在应用层和传输层基础上的安全协议，为计算机上的Shell(壳层)提供安全的传输和使用环境


- SSH采用先 非对称后对称 进行数据加密 但是有中间人攻击问题
- 黑客H埋伏在了A和B之间的某一个路由器上，他假冒B生成一对公私密钥，然后把公钥发送给A，这样A与H之间就建成了一个加密通道，A把所有信息发送给H，H截获A的信息，在假冒A与B通信。
- 如此一来，A、B之间的通信就完全暴漏给了H，而A、B却完全不知道，这就是的中间人攻击。


- SSH协议采用由人工判断公钥的fingerprint是否可信的方式。当使用ssh命令连接服务器时，命令行会提示如下信息:

```shell
RSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53.
Are you sure you want to continue connecting (yes/no)? 
```

fingerprint其实就代表公钥,这种认证方式是指用户已经知道服务器公钥(黑客不可能发一个与服务器一模一样的公钥)，这样就解决了问题

### 为更广大群众设计的SSL与TLS

- SSH弊端：SSH其实是专门为shell设计的一种通信协议，只有SSH客户端，和SSH服务器端之间的通信才能使用这个协议

- SSL与TLS(SSL协议的一个后续版本)是一个通用的，建立在应用层之下的一个传输层安全协议，不管是HTTP、FTP等应用层协议都可以依赖的安全通信的传输层协议(应用层和传输层之间的一个安全通道)

- SSH通过fingerprint来解决中间人问题，那么SSL是通过数字证书(CA数字证书认证机构颁发的)来解决的

  - 浏览器在与服务器建立SSL连接时，获取服务器的数字证书

  - 证书里面有签名(服务器公钥经过CA私钥加密生成的)

  -  这样浏览器得到证书，用CA的公钥（每个浏览器都存储着一些权威CA的公钥）对数字签名解密，得到了服务器公钥

  -  解密成功说明证书是真的(不是中间人发的)，信任问题就这么解决了，就可以用公钥了

### HTTPS(Hypertext Transfer Protocol Secure)

> HTTP over TLS 或者 HTTP over SSL,其实就客户端与服务器之间的HTTP通信基于TLS或SSL协议。

作为网站管理员申请数字证书：首先要为服务器生成一对公私钥，然后将公钥一起发送给某个权威的CA，CA会通过某种方式认证申请人是否真的是网站的所有人，验证通过就会得到证书了。


### 开发

- 如果客户端已经和服务器私底下配置了公钥(客户端),私钥(服务器)，那么不需要证书了(因为确保了这个公钥是从服务器来的)，
 
- 客户端将对称key通过公钥进行加密，然后服务器通过私钥将其解密，之后的前后端交互通过对称key即可

- 服务器生成公私钥，客户端要安全的拿到公钥，然后客户端自己生成一个key用公钥加密传给服务器，之后的数据加解密都是通过这个key

### 使用加密算法能保证密码安全吗

- 对称加密

前端加密无非是写在JS里，但是JS有风险被直接破解从而识别加密方法

- HTTPS就一定安全吗

    - HTTPS可以保证传输过程中的信息不被别人截获，但是细细思考下，HTTPS是应用层协议，下层采用SSL保证信息安全，但是在客户端和服务端，密文同样是可以被截获的

    - HTTPS报文在传输过程中，如果客户端被恶意引导安装“中间人”的WEB信任证书，那么HTTPS中的“中间人攻击”一样会将明文密码泄露给别人

- 无论HTTP还是HTTPS，密码必须密文传输

- 黑客拿到密码密文，然后发送给服务器不是一样可以登录，解决方式：token令牌，每次从服务器中获取认证的token，确实能保证HTTP请求是由前端传回来的，因为token在每次接口访问后都会删除并被重置，黑客尝试**重放**账号密码数据信息来登陆的时候导致无法成功登陆

### 数据篡改

- 密码加密了，黑客看不到明文了；加上token，登陆过程也没法再被截获重放了

- 当请求路由到黑客这边的时候，截获数据包，然后也不需要登录，反正账号密码都是对的，token也是对的，那么把数据包的字段改改，搞破坏就可以了

- 解决：数字签名

### 签名vs加密

> 数据签名和数据加密的过程都是使用公开的密钥系统，但实现的过程正好相反

- 公钥和私钥唯一对应，用某个公钥签名过得内容只能用对应的私钥才能解签验证；同样用某个私钥加密的内容只能用对应的公钥才能解密

- 公钥一般用来加密，私钥用来签名

- A向B发送信息的整个签名和加密的过程如下：

  - A用自己的私钥对data进行签名
  
  - A使用B的公钥对全部报文进行加密

- B接收到A的信息后，获取信息内容的步骤如下：

  - B用自己的私钥加密的内容
  
  - 得到解密后的明文后用A的公钥解签A的签名获取data

总结：A的签名只有A的公钥才能解签，这样B就能确认这个信息是A发来的；A的加密只有B的私钥才能解密，这样A就能确认这份信息只能被B读取

### JS加密函数存在被破解

摘要或加密JS算法不直接以静态文件的形式存在浏览器中，而是让WEB端去请求Server，服务器可以根据随机令牌token值决定返回一个相应随机的加密策略，以JS代码响应的方式返回，在异步请求响应中，加载JS摘要算法，这样客户端就可以动态加载数字摘要策略，保证无法仿造
