---
title: tree
categories:
- leetcode


---

#### 遍历

```java
    /**
     * 1.根节点入栈
     * 2.当栈非空时，栈顶出栈，把出栈的节点值添加到list，然后依次再入栈其右子节点和左子节点
     *
     * @param root
     */
    public void preOrder(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode curr = stack.pop();
            list.add(curr.val);
            if (curr.right != null) {
                stack.push(curr.right);
            }
            if (curr.left != null) {
                stack.push(curr.left);
            }
        }
    }

    /**
     * 1.根节点入栈
     * 2.初始化curr为root
     * 3.当栈非空或curr非null时，循环
     *  1 cur != null时，说明还有左子节点存在，入栈，并且cur置为自己的左子节点
     *  2 cur == null时，说明到树最左的节点了，栈顶节点出栈，cur置为栈顶节点的右子节点
     *
     * @param root
     */
    public void inOrder(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode curr = root;
        while (!stack.isEmpty() || curr != null) {
            if (curr != null) {
                stack.push(curr);
                curr = curr.left;
            } else {
                curr = stack.pop();
                list.add(curr.val);
                curr = curr.right;
            }
        }
    }

    /**
     * 前序遍历的反操作
     *
     * @param root
     */
    public void postOrder(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode curr = stack.pop();
            list.add(0, curr.val);
            if (curr.left != null) {
                stack.push(curr.left);
            }
            if (curr.right != null) {
                stack.push(curr.right);
            }
        }
    }
```

- #### [完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```java
    public int countNodes(TreeNode root) {
        if (root == null)
            return 0;
        // 计算左右孩子个数
        int leftCount = countNodes(root.left);
        int rightCount = countNodes(root.right);
        // 左孩子个数+右孩子个数+1 就是当前节点的个数
        return leftCount + rightCount + 1; 
    }
```

- #### [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```java
    public TreeNode invertTree(TreeNode root) {
        if (root == null)
            return null;
        // 当前root节点的左孩子
        TreeNode left = root.left;
        // 当前root节点的右孩子
        TreeNode right = root.right;
        // 交换左右孩子
        root.left = right;
        root.right = left;
        // 对左右孩子进行递归
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
```

- #### [填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```java
    public TreeNode connect(TreeNode root) {
        if (root == null)
            return null;
        // 一个节点解决不了 就用两个节点
        connectTwo(root.left,root.right); 
        return root;
    }

    void connectTwo(TreeNode left,TreeNode right) {
        // 只要左孩子或者右孩子有一个是空，直接返回
        if (left == null || right == null)
            return;
        // 将左孩子连接到右孩子
        left.next = right; 
		// 进行三个递归
        connectTwo(left.left,left.right);
        connectTwo(right.left,right.right);
        // 两个父节点不一样的话 也要考虑到
        connectTwo(left.right,right.left); 
    }
```

- #### [重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```java
    // 将前序数组移到成员变量
	int[] pre;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.pre = preorder;
        Map<Integer, Integer> map = new HashMap<>();
        // 将中序数组存入map
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return dfs(0,0, preorder.length - 1, map);
    }

    TreeNode dfs(int root, int start, int end, Map<Integer, Integer> map) {
        // 如果
        if (start > end) {
            return null;
        }
        // 每次先取根节点
        int i = pre[root];
        TreeNode node = new TreeNode(i);
        // 确定根节点在中序数组中的位置
        int ii = map.get(i);
        // start和ii - 1代表的是中序数组的左孩子，root + 1代表的是前序数组的根节点
        node.left = dfs(root + 1, start, ii - 1, map);
        // ii + 1和end代表的是中序数组的右孩子，ii - start代表左孩子的长度，+root根节点偏移量再+1==右孩子的根节点
        node.right = dfs(ii - start + root + 1, ii + 1, end, map);
        return node;
    }
```

- #### [树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

```java
    public boolean isSubStructure(TreeNode a, TreeNode b) {
        // 如果递归到尾部 返回false
        if (a == null || b == null) {
            return false;
        }
        // 进行三个递归
        boolean flag = dfs(a, b);
        boolean flag1 = isSubStructure(a.left, b);
        boolean flag2 = isSubStructure(a.right, b);
        return flag || flag1 || flag2;
    }

    boolean dfs(TreeNode a, TreeNode b) {
        // 如果子树b是null 返回true
        if (b == null) {
            return true;
        }
        // 如果a递归到了null 或者值不等 直接返回false
        if (a == null || a.val != b.val) {
            return false;
        }
        return dfs(a.left, b.left) && dfs(a.right, b.right);
    }
```

- #### [对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

```java
    public boolean isSymmetric(TreeNode root) {
        // 两个形参传递
        return dfs(root, root);
    }

    private boolean dfs(TreeNode left, TreeNode right) {
        // 如果都递归到了null 返回true
        if (left == null && right == null)
            return true;
        // 只要有一个为null 或者值不相等就返回false
        if (left == null && right != null || right == null && left != null || left.val != right.val)
            return false;
        return dfs(left.left, right.right) && dfs(left.right, right.left);
    }
```

- #### [从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

```java
    public int[] levelOrder(TreeNode root) {
        if (root == null)
            return new int[0];
        // 定义一个队列
        Queue<TreeNode> queue = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        // 将root加入到队列
        queue.add(root);
        // 只要队列不为空就一直循环下去
        while (!queue.isEmpty()) {
            // 出队
            TreeNode node = queue.poll();
            // 添加记录
            list.add(node.val);
            // 将左右孩子添加到队列中
            if (node.left != null)
                queue.add(node.left);
            if (node.right != null)
                queue.add(node.right);
        }
        int[] arrs =  new int[list.size()];
        int l = 0;
        for (Integer i :list)
            arrs[l++] = i;
        return arrs;
    }
```

- #### [从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null)
            return new ArrayList<>();
        // 定义队列
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        List<List<Integer>> res = new ArrayList<>();
        while (!queue.isEmpty()) {
            // 每次循环定义一个list
            List<Integer> list = new ArrayList<>();
            // 求当前队列的长度
            int size = queue.size();
            // 循环长度
            for (int i = 0; i < size; i++) {
                // 每次poll出来
                TreeNode node = queue.poll();
                // 加入到list
                list.add(node.val);
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
            }
            // for循环结束后将list加入到结果集
            res.add(list);
        }
        return res;
    }
```

- #### [从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null)
            return new ArrayList<>();
        // 定义队列
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        // 定义一个数判断奇偶
        int k = 1;
        List<List<Integer>> res = new ArrayList<>();
        while (!queue.isEmpty()) {
            // 每次进循环定义一个List
            List<Integer> list = new ArrayList<>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                // 如果k是偶数
                if (k % 2 == 0) {
                    // list倒着加
                    list.add(0,node.val);
                } else {
                    list.add(node.val);
                }
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
            }
            // for循环结束后将List加入到结果集
            res.add(list);
            // k++
            k++;
        }
        return res;
    }
```

- #### [二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

```java
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> list = new ArrayList<>();
	public List<List<Integer>> pathSum(TreeNode root, int target) {
        // 定义一个num记录当前的路径和
        dfs(root, 0, target);
        return res;
    }
    void dfs(TreeNode root, int num, int target) {
        // 如果遍历到了尾部直接返回
        if (root == null) {
            return;
        }
        // num+当前节点的值
        num += root.val;
        // 加入到list
        list.add(root.val);
        // 如果到达尾部并且值与目标值相等加入到结果集
        if (root.left == null && root.right ==null && num == target) {
            // 这里注意要new一个，新建一个对象，不然一直都是一个对象
            res.add(new ArrayList<>(list));
        }
        // 进行dfs递归
        dfs(root.left, num, target);
        dfs(root.right, num, target);
        // 这里只要对list进行回溯即可，不用对num，因为num是值传递，递归返回上一层时还是上一层的值
        list.remove(list.size() - 1);
    }
```

- #### [二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```java
    public int kthLargest(TreeNode root, int k) {
        dfs(root);
        // list索引下标0->size - 1
        return list.get(list.size() - k);
    }
    private List<Integer> list = new ArrayList<>();
    private void dfs(TreeNode root) {
        if (root == null)
            return ;
        dfs(root.left);
        // 中序遍历依次加入到结果集
        list.add(root.val);
        dfs(root.right);
    }
```

- #### [二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

```java
    public int maxDepth(TreeNode root) {
        // 递归到了尾部 返回深度0
        if (root == null)
            return 0;
        int m = maxDepth(root.left);
        int n = maxDepth(root.right);
        // 当前节点的深度为左右孩子深度的最大值+1
        return Math.max(m,n) + 1;
    }
```

- #### [平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

```java
    public boolean isBalanced(TreeNode root) {
        // 遍历到根节点 返回true
        if (root == null)
            return true;
        // 返回值：当前节点左右孩子的深度差小于1，然后遍历左右孩子(保证每个节点)
        return Math.abs((dfs(root.left) - dfs(root.right))) <= 1 && isBalanced(root.left) && isBalanced(root.right);
    }

    private int dfs(TreeNode root) {
        // 判断每个节点的深度
        if (root == null)
            return 0;
        int left = dfs(root.left);
        int right = dfs(root.right);
        return Math.max(left,right) + 1;
    }
```

- #### [二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```java
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 只要root不遍历到null 一直循环下去
        while (root != null) {
            // 当前值比两个节点的值都要大，root向左移
            if (p.val < root.val && q.val < root.val)
                root = root.left;
            // 当前值比两个节点的值都要小，root向右移
            else if (p.val > root.val && q.val > root.val)
                root = root.right;
            else
                break;
        }
        return root;
    }
```

