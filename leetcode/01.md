---
title: tree
categories:
- leetcode

---

### 树的结构

```java
public class TreeNode {
    private int val;
    private TreeNode left;
    private TreeNode right;
    public TreeNode (int x) {
        x = val;
    }
}
```

- #### [完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```java
    public int countNodes(TreeNode root) {
        if (root == null)
            return 0;
        // 计算左右孩子个数
        int leftCount = countNodes(root.left);
        int rightCount = countNodes(root.right);
        // 左孩子个数+右孩子个数+1 就是当前节点的个数
        return leftCount + rightCount + 1; 
    }
```

- #### [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```java
    public TreeNode invertTree(TreeNode root) {
        if (root == null)
            return null;
        // 当前root节点的左孩子
        TreeNode left = root.left;
        // 当前root节点的右孩子
        TreeNode right = root.right;
        // 交换左右孩子
        root.left = right;
        root.right = left;
        // 对左右孩子进行递归
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
```

- #### [填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```java
    public TreeNode connect(TreeNode root) {
        if (root == null)
            return null;
        // 一个节点解决不了 就用两个节点
        connectTwo(root.left,root.right); 
        return root;
    }

    void connectTwo(TreeNode left,TreeNode right) {
        // 只要左孩子或者右孩子有一个是空，直接返回
        if (left == null || right == null)
            return;
        // 将左孩子连接到右孩子
        left.next = right; 
		// 进行三个递归
        connectTwo(left.left,left.right);
        connectTwo(right.left,right.right);
        // 两个父节点不一样的话 也要考虑到
        connectTwo(left.right,right.left); 
    }
```

- #### [重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```java
    // 将前序数组移到成员变量
	int[] pre;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.pre = preorder;
        Map<Integer, Integer> map = new HashMap<>();
        // 将中序数组存入map
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return dfs(0,0, preorder.length - 1, map);
    }

    TreeNode dfs(int root, int start, int end, Map<Integer, Integer> map) {
        // 如果
        if (start > end) {
            return null;
        }
        // 每次先取根节点
        int i = pre[root];
        TreeNode node = new TreeNode(i);
        // 确定根节点在中序数组中的位置
        int ii = map.get(i);
        // start和ii - 1代表的是中序数组的左孩子，root + 1代表的是
        node.left = dfs(root + 1, start, ii - 1, map);
        node.right = dfs(ii - start + root + 1, ii + 1, end, map);
        return node;
    }
```

- #### [树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

```java
    public boolean isSubStructure(TreeNode a, TreeNode b) {
        if (a == null || b == null) {
            return false;
        }
        boolean flag = dfs(a, b);
        boolean flag1 = isSubStructure(a.left, b);
        boolean flag2 = isSubStructure(a.right, b);
        return flag || flag1 || flag2;

    }

    boolean dfs(TreeNode a, TreeNode b) {
        if (b == null) {
            return true;
        }
        if (a == null || a.val != b.val) {
            return false;
        }
        return dfs(a.left, b.left) && dfs(a.right, b.right);
    }
```

- #### [二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

```java
    public TreeNode mirrorTree(TreeNode root) {
        if (root == null)
            return null;
        TreeNode temp = root.right;
        root.right = root.left;
        root.left = temp;
        mirrorTree(root.left);
        mirrorTree(root.right);
        return root;
    }
```

- #### [对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

```java
    public boolean isSymmetric(TreeNode root) {
        return isTest(root, root);
    }

    private boolean isTest(TreeNode left, TreeNode right) {
        if (left == null && right == null)
            return true;
        if (left == null && right != null || right == null && left != null
                || left.val != right.val)
            return false;

        return isTest(left.left, right.right) && isTest(left.right, right.left);

    }
```

- #### [从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

```java
    public int[] levelOrder(TreeNode root) {
        if (root == null)
            return new int[0];
        Queue<TreeNode> queue = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            list.add(node.val);
            if (node.left != null)
                queue.add(node.left);
            if (node.right != null)
                queue.add(node.right);
        }
//        Arrays.asList()
        int[] arrs =  new int[list.size()];
        int l = 0;
        for (Integer i :list)
            arrs[l++] = i;
        return arrs;
    }
```

- #### [从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null)
            return new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        List<List<Integer>> list2 = new ArrayList<>();
        while (!queue.isEmpty()) {
            List<Integer> list = new ArrayList<>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
            }
            list2.add(list);
        }
        return list2;
    }
```

- #### [从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null)
            return new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int k = 1;
        List<List<Integer>> list2 = new ArrayList<>();
        while (!queue.isEmpty()) {
            List<Integer> list = new ArrayList<>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (k % 2 == 0) {
                    list.add(0,node.val);
                } else {
                    list.add(node.val);
                }
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
            }
            list2.add(list);
            k++;
        }
        return list2;

    }
```

- #### [二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

```java
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        dfs(root, 0, target);
        return res;
    }
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> list = new ArrayList<>();
    void dfs(TreeNode root, int num, int target) {
        if (root == null) {
            return;
        }
        num += root.val;
        list.add(root.val);
        if (root.left == null && root.right ==null && num == target) {
            res.add(new ArrayList<>(list));
        }
        dfs(root.left, num, target);
        dfs(root.right, num, target);
        list.remove(list.size() - 1);
    }
```

- #### [二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```java
    public int kthLargest(TreeNode root, int k) {
        test(root);
        return list.get(list.size()-k);
    }
    private List<Integer> list = new ArrayList<>();
    private void test(TreeNode root) {
        if (root == null)
            return ;
        test(root.left);
        list.add(root.val);
        test(root.right);

    }
```

- #### [二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

```java
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        int m = maxDepth(root.left);
        int n = maxDepth(root.right);
        return Math.max(m,n) + 1;
    }
```

- #### [平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

```java
    public boolean isBalanced(TreeNode root) {
        if (root == null)
            return true;
        return Math.abs((test(root.left) - test(root.right))) <= 1 && isBalanced(root.left) && isBalanced(root.right);
    }

    private int test(TreeNode root) {
        if (root == null)
            return 0;
        int left = test(root.left);
        int right = test(root.right);
        return Math.max(left,right) + 1;
    }
```

- #### [二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```java
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while (root != null) {
            if (p.val < root.val && q.val < root.val)
                root = root.left;
            else if (p.val > root.val && q.val > root.val)
                root = root.right;
            else
                break;
        }
        return root;
    }
```

