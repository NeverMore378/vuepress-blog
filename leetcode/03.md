---
title: sort
categories:
 - leetcode
---


### 冒泡排序

```java
public class Bubble {
    
    public static int[] sort(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = arr.length - 1; j > i; j--) {
                if (arr[j] < arr[j - 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j - 1];
                    arr[j - 1] = temp;
                }
            }
        }
        return arr;
    }
    
    public static void main(String[] args) {
        int[] sort = sort(new int[]{2, 1, 3});
        for (int i : sort) {
            System.out.println(i);
        }
    }
}
```

### 插入排序

```java
public class Insertion {
    
    private static int[] sort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            for (int j = i; j > 0; j--) {
                if (arr[j] < arr[j - 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j - 1];
                    arr[j - 1] = temp;
                } else
                    //  如果当前元素比之前的元素大的话直接跳出 因为前面已经是排好序的
                    break;
            }
        }
        return arr;
    }

    public static void main(String[] args) {
        int[] sort = sort(new int[]{4,5,6,1,2,3});
        for (int i : sort) {
            System.out.println(i);
        }
    }
}
```

### 选择排序

```java
public class Select {

    private static int[] sort(int[] arr) {
        for(int i = 0 ; i < arr.length - 1; i++) {
            int min = i;
            for(int j = i + 1; j < arr.length ; j++) {
                if (arr[j] < arr[min]) {
                    min = j;
                }
            }
            int temp = arr[i];
            arr[i] = arr[min];
            arr[min] = temp;
        }
        return arr;
    }

    public static void main(String[] args) {
        int[] sort = sort(new int[]{2, 1, 3});
        System.out.println(Arrays.toString(sort));
    }
}
```

### 希尔排序

```java
public class Shell {

    public static void sort(int[] arr) {
        int h = 2;
        // h 增量到1就结束了 h为1就是插入排序
        while (h > 0) {
            // 和插入排序不同的是起始是从h 开始 直到最后一个元素
            for (int i = h; i < arr.length; i++) {
                // 和之前的 h 增量元素 进行插入排序
                for (int j = i; j - h >= 0; j -= h) {
                    if (arr[j] < arr[j - h]) {
                        int temp = arr[j];
                        arr[j] = arr[j - h];
                        arr[j - h] = temp;
                    } else
                        break;
                }
            }
            h /= 2;
        }
    }

}
```

### 快速排序

```java
public class Quick {

    private static int[] sort(int[] arr, int begin, int end) {
        // 主要和归并进行比较  都是 >= 的时候结束递归
        if (begin >= end)
            return arr;
        int temp = arr[begin];
        int i = begin,j = end;
        while(i < j) {
            // 要注意这里必须有一个 = 号 不然的的话有可能出现两个while都是false 则一直会循环下去
            while (i < j && arr[j] >= temp)
                j--;
            arr[i] = arr[j];
            while (i < j && arr[i] < temp)
                i++;
            arr[j] = arr[i];
        }
        arr[i] = temp;
        // 这里要注意和归并不同 先序已经有一个元素在指定位置了 
        sort(arr,begin,i - 1); 
        sort(arr,i + 1,end);
        return arr;
    }

    public static void main(String[] args) {
        int[] sort = sort(new int[]{1, 2, 4, 5, 7, 4, 5, 3, 9, 0}, 0, 9);
        for (int i : sort) {
            System.out.println(i);
        }
    }
}
```

### 归并排序

```java
public class Merge {

    /**
     * 两路归并算法，两个排好序的子序列合并为一个子序列
     * @param a
     * @param left
     * @param mid
     * @param right
     */
    public void merge(int[] a, int left, int mid, int right) {
        // 辅助数组
        int[] tmp = new int[a.length];
        // p1、p2是检测指针，k是存放指针
        int p1 = left, p2 = mid + 1, k = left;
        while (p1 <= mid && p2 <= right) {
            if (a[p1] <= a[p2])
                tmp[k++] = a[p1++];
            else
                tmp[k++] = a[p2++];
        }
        // 如果第一个序列未检测完，直接将后面所有元素加到合并的序列中
        while (p1 <= mid) tmp[k++] = a[p1++];
        while (p2 <= right) tmp[k++] = a[p2++];
        // 复制回原数组
        for (int i = left; i <= right; i++)
            a[i] = tmp[i];
    }

    public void mergeSort(int[] a, int start, int end) {
        if (start >= end)
            return;
        // 划分子序列
        int mid = (start + end) / 2;
        // 对左侧子序列进行递归排序
        mergeSort(a, start, mid);
        // 对右侧子序列进行递归排序
        mergeSort(a, mid + 1, end);
        // 合并
        merge(a, start, mid, end);

    }

    @Test
    public void test() {
        int[] a = {49, 38, 65, 97, 76, 13, 27, 50};
        mergeSort(a, 0, a.length - 1);
        for (int e : a)
            System.out.print(e + " ");
    }
}
```

### 堆排序

```java
public class HeapSort {

    /**
     * 堆 (完全二叉树,不是堆栈的堆，每个结点的值都大于或等于其左右孩子结点的值 (大根堆) ，不是二叉查找树)
     *
     * @param args
     */
    public static void main(String[] args) {
        int[] arr = {2, 1, 4, 3, 5};
        heapSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    private static void heapAdjust(int[] arr, int parent, int length) {
        // 取左孩子节点
        int child = 2 * parent + 1;
        // 当孩子节点小于数组长度时一直循环下去
        while (child < length) {
            // 如果右孩子节点存在且右孩子的值大于左孩子的值
            if (child + 1 < length && arr[child] < arr[child + 1]) {
                // 孩子指针向右指针移动
                child++;
            }
            // 如果孩子节点的值小于父节点的值 跳出循环
            if (arr[child] < arr[parent])
                break;
            // 否则将孩子节点与父节点交换
            int node = arr[parent];
            arr[parent] = arr[child];
            arr[child] = node;
            // 父节点移动到孩子节点
            parent = child;
            // 孩子节点移动到孩子节点的孩子节点
            child = 2 * parent + 1;
        }
    }

    private static int[] heapSort(int[] arr) {
        int length = arr.length;
        // 构建大根堆
        for (int i = length / 2 - 1; i >= 0; i--) {
            heapAdjust(arr, i, length);
        }
        // 将根节点(堆的根节点)与最后一个节点交换
        for (int i = length - 1; i > 0; i--) {
            int temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;
            // 交换完后重新构建大根堆
            heapAdjust(arr, 0, i);
        }
        return arr;
    }
}
```

### 基数排序

```java
public class MyRadix {

    public static void main(String[] args) {
        int[] arr = {73, 22, 93, 43, 55, 14, 28, 65, 39, 81};
        radix(arr);
        System.out.println(Arrays.toString(arr));
    }

    private static void radix(int[] arr) {
        // 找出最大的元素
        int max = findMax(arr);
        // 循环最大元素的位数次
        for (int i = 1; max / i > 0; i *= 10) {
            int len = arr.length;
            int[][] buckets = new int[len][10];
            // 获取每一位的数字，然后加入桶里
            for (int j = 0; j < len; j++) {
                int weight = (arr[j] / i) % 10;
                buckets[j][weight] = arr[j];
            }
            // 回收桶里的元素(对二维数组按列进行遍历)
            int k = 0;
            for (int c = 0; c < 10; c++) {
                for (int r = 0; r < len; r++) {
                    if (buckets[r][c] != 0) {
                        arr[k++] = buckets[r][c];
                    }
                }
            }
        }
    }

    private static int findMax(int[] arr) {
        int max = Integer.MIN_VALUE;
        for (int num : arr) {
            if (num > max) {
                max = num;
            }
        }
        return max;
    }
    
}
```

### 时空复杂度

|类别|排序|平均|最坏|最好|空间|稳定性|
|---|---|---|---|---|---|---|
|交换排序|冒泡|o(n^2)|o(n^2)|o(n)|o(1)|yes|
|交换排序|快速|o(n*logn)|o(n^2)|o(n*logn)|o(logn)|no|
|插入排序|直插|o(n^2)|o(n^2)|o(n)|o(1)|yes|
|插入排序|希尔|o(n*logn)|o(n^2)| |o(1)|no|
|选择排序|选择|o(n^2)|o(n^2)|o(n^2)|o(1)|no|
|选择排序|堆排|o(nlogn)|o(nlogn)|o(nlogn)|o(1)|no|
|归并排序|归并|o(nlogn)|o(nlogn)|o(nlogn)|o(n)|yes|
|基数排序|基数|o(d*n)|o(d*n)|o(d*n)|o(n)|yes
